
## 인수테스트

# 시기상조의 정밀도
- 불확실성의 원칙 : 기능을 볼 수록 새로운 시각을 가지게 된다. 요구사항이 정밀해질수록 최종 구현된 시스템과 초기 요구사항의 차이는 벌어진다.
- 불안한 추정 : 요구사항은 반드시 바뀌기 때문에 초기 정밀도는 고려할 가치가 없다. 정밀도가 낮은 요구사항을 바탕으로 추정한다. 추정에 오차범위를 추가해 불확실성을 이해하게 만든다.

# 때늦은 모호함
- 개발직전까지 요구사항에 살을 붙이지 않는다
- 모두가 동의하도록 요구사항의 표현을 우회하는 방법을 찾아낸다.
- 요구사항에서 모든 모호함을 제거하는 일이 프로의 책임

# 인수테스트
- 요구사항이 언제 '완료'되는지 정의하기 위해, 이해 당사자들과 프로그래머들이 함께 작성하는 테스트
- '완료'의 정의 : 코드 작성, 테스트 통과, QA 전문가와 이해 당사자들이 이를 인수함
- 자동화 테스트 & 통과 => 완료

# 의사소통
- 인수테스트의 목적 : 소통, 명확성, 정밀성
- 프로 개발자는 모든 당사자들이 결과물에 대해 인지보장을 위해 이해 당사자 및 테스트와 함게 하는 작업에 책임을 진다

# 자동화
- 수작업 테스트의 비용
- 프로 개발자는 인수 테스트 자동화의 보장에 책임을 진다

# 추가작업
- 인수테스트를 만드는 일은 정말 엄청난 추가 작업처럼 보인다.
- 인수 테스트는 프로그래머들이 '완료'의 의미를 이해하는 유일한 방법이고, 이해당사자가 필요한 바를 보장하는 유일한 방법
- 많은 시간과 비용에 대한 절약으로 봐야 한다.
- 잘못된 시스템 구현을 막고 완료한 때를 알게 해준다.
==> 정말 이상적인 프로세스에요! 여유 있게 경험 해볼 수 있으면 좋겠네용!

# 누가 인수테스트를 작성하는가
- 사업분석가들은 행복한 경로 버전을 작성
- QA는 좋지 않은 경로 테스트, 경계조건, 예외사항, 구석 사례를 작성
- "기능 구현 며칠 전에 가능한 늦게 작성한다. 다음 스프린트에서 구현할 기능 선정 후 작성한다"
==> '트랙 핵심 시나리오 = 인수 테스트' 라고 볼 때 핵심 시나리오를 테스트 코드로 녹여낼 수 있을까?
==> 이렇게 하려면, 스프린트가 좀 더 톱니바퀴처럼 착착, 빡빡하게 돌아가야 하겠다는 생각이 든다.

# 개발자의 역할
- 인수 테스트 실행, 오류 확인, 시스템에 연결해 테스트 통과 과정을 시작

# 테스트 협상과 수동적 공격성
- 팀이 가능한 최상의 소프트웨어를 만드는데 도움을 주는 것이 프로의 일
- 모든 이가 오류와 실수를 살펴 함께 바로 잡는 일

# 인수 테스트와 단위 테스트
- 단위 테스트는 프로그래머가 프로그래머를 위해 만든다.
- 단위 테스트는 특정 클래스의 메소드 호출, 시스템 내부로 파고든다
- 인수 테스트는 API, UI 수준의 시스템 호출을 한다
- 테스트의 주 묵적 : 시스템의 디자인, 구조 및 행동을 문서화

# GUI 및 다른 문제점
- GUI 인수테스트 작성 어려움 => API인 것처럼 GUI를 만들도록 설계한다
- 예, 버튼의 고유 아이디를 이용해 해당 버튼을 클릭하는 테스트를 작성

# 올바른 인터페이스를 통한 테스트
- GUI를 통하는 것보다 실제 API를 통해 기능을 불러오는 테스트를 작성
- GUI와 비즈니스 로직을 분리
- GUI를 테스트 하는 동안 업무 규칙을 스텁으로 교체하는 것이 좋다?

# 지속적 통합
- 모든 단위 / 인수 테스트를 계속 실행할 수 있도록 하라 => 잘 되있음에 감사
- 테스트 실행 결과를 팀 내 모든 인원에게 이메일로 보내야 한다.

# 결론
- 양 당사자들이 완전히 다른 개념으로 이해하고 헤어지는 경우가 흔하다

=> 매우 이상적 ! 인수 테스트를 작성해 요구사항을 모호성 없이 작성하고, 완료의 기준으로 삼는다. 이 인수 테스트는 그 자체로 요구사항과 결과의 문서가 된다.
=> 외주를 하게 된다면 도전해보고 싶은 프로세스!
=> 처음에 이해하는데 단어들이 생소했어서 어려움이 있었지만, 두번째 읽고 얘기하다 보니 지금 업무 방식에 조금 일맥상통하는 부분이 깨달아지며 이해가 됬습니다.