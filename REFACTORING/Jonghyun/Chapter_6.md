Chapter 6 기본적인 리팩터링

## Discussion:

### 6.1 함수 추출하기 (Extract Function)
#### 배경:
무슨일을 하는 지 파악 후 독립된 함수로 추출 with 적절한 이름  
밥 아저씨 의견에는 목적과 구현을 분리하는 방식이 베스트:  
함수의 제목과는 딱히 상관없는 일을 하고 있는 코드를 분리 -> 적절한 새로운 이름의 함수로 제 편성.  
이 방식으로 코딩하면 목적이 더 명확해지고 신경쓸 일이 줄어듬.  

이 원칙을 적용하면 할 수록 함수가 아주 짧아지고, 작게 작성하는 습관이 생기게 된다 한다.  
밥 아저씨 의견엔 6줄 이상 부턴 슬 냄새가 난다고 한다.. 이 부분은 좀 노력을 해봐야 할 듯 하다.  
성능 최적화에 대한 고민은 사실상 의미없는 경우가 많으므로 하지 말자..  

#### 절차:
1. 함수를 새로 만들고, 이름을 붙인다.
   1. 무엇을 하는지가 드러나야 한다.
2. 추출한 코드를 원본에 붙여넣는다
3. 추출한 코드 중 원본의 지역 변수를 참조하거나 유효범위를 벗어나는 변수가 있나 확인한다.
   1. 이 과정에서 챕터 1에서 설명한 변수의 선언위치, 인자로 넘기기 등을 한다
4. 컴파일한다
5. 원본의 블락을 새로 만든 함수로 바꾼다
6. 테스트
7. 다른 코드에도 비슷하게 추출할 수 있는 코드가 있는 지 확인한다. 있다면 변경하는 한지 확인하고 

### 6.2 함수 인라인하기 (Inline Function)
#### 배경:
쓸모 없는 간접호출, 잘못 추출된 함수, 또 과하게 간접호출을 쓰는 코드 등이 인라인의 대상이다. 

#### 절차:
1. 다형 메서드 (Polymorphic Method) 인지 확인한다.
   1. **서브 클래스에서 오버라이드 하는 메서드는 인라인하면 안된다**
2. 인라안할 함수를 호출하는 곳을 모두 찾는다
3. 각 호출문을 함수 본문으로 교체한다
4. 하나씩 교체할 떄 마다 테스트한다.
   1. 인라인 작업을 한번에 하기보단, 여유를 가지고 천천히 진행하
5. 기존 함수를 삭제

인라인은 간단해 보이지만 막상 실천하려면 어려운 경우가 있다. 재귀 호출, 반환문이 여러개인 함수, 접근자가 없는 다른 객체에 메서드를 인라인하는 방법 등 굉장히 복잡한 경우가 많이 있을 수 있다.  

### 6.3 변수 추출하기 (Extract Variable)
하나의 표현식 등이 너무 복잡하여 이해하기 어려울 때가 있을 때는 지역변수 등을 활용해 표현식을 쪼개 관리하면 더 쉽게 만들 수 있다 한다.

여기서 궁금한 건, 밥 아저씨는 6줄 이상부턴 코드 스멜이 난다하던데 이렇게 변수를 추출하면 로직상 쓸데없는 코드가 늘어 길어지게 된다 생각이 듭니다. 표현식을 리턴하기만 하는 함수를 만들어서(함수 추출하기) 그냥 지역 변수를 추가 작업 없이 리턴하는 함수의 이름을 명확하게 짖는 것은 어떨까 궁금합니다.  

이 물음에 대해 이름을 지을 때 문맥을 넓게 잡아 쓰다보면 할일이 늘어나 해당 함수가 넓은 밥 아저씨 만의 답변이 오긴 했지만, 뭔가 개인적으론 이해가 잘 가지 않는 부분인 것 같습니다.  

#### 절차:
1. 추출하려는 표현식에 부작용은 없는지 확인한다.
2. 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다.
3. 원본 표현식을 새로 만든 변수로 교체한다.
4. 테스트
5. 표현식을 여러 곳에서 사용 중이라면 각각을 새로 만든 변수로 교체하고 매 교체마다 테스트한다.

### 6.4 변수 인라인하기 (Inline Variable)
#### 배경:
변수의 이름이 원래 표현식과 다를바가 없고, 표현식으로 이해하는게 충분하고, 그 외 주변코드의 리팩토링을 방해한다면 변수를 인라인하는게 좋다.  

위에 (6.3) 내 의문에 대한 대답이 여기 있다는 생각이 들긴 한다. 내가 든 예시가 적절했는지 여부가 조금 확신이 없다는 느낌이다.   

#### 절차:
1. 대입문의 우변(표현식)에서 부작용이 생기지는 않는지 확인
2. 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트
   1. 이 방법을 통해 변수가 단 한 번만 대입되는지 알 수 있다
3. 변수를 가장 처음 사용하는 코드를 찾아서 = 의 우변의 코드를 변경
4. 테스트
5. 해당 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다.
6. 변수 선언문과 대입문을 삭제
7. 테스트

### 6.5 함수 선언 바꾸기 (Change Function Declaration)
#### 배경:
함수는 시스템의 구성 요소를 조립하는 연결부. 그리고 이 연결부들의 가장 중요한 요소는 함수의 이름. 이름만 보고도 무슨 일을 하는지 파악할 수 있는 이름을 지어야 한다.  
고작 이름이 아니라 무려 이름이기 때문에 영혼을 갈아서라도 좋은 이름을 생각해 내는게 중요하다.  

이는 매계변수도 마찬가지이다. 매계변수로 어떠한 이름의 값을 받느냐가 잘 정의되면 함수의 도메인 컨텍스트 상에서의 범위를 알 수 있다는 의견인 듯 하다.  
이러한 생각을 가지고 코드를 작성하면 코드의 결합도도 내려가는 효과도 있다.  

#### 절차:
함수 선언 바꾸기는 2가지의 절차로 진행이 가능한데, 간단한 절차로 충분한 경우가 있고, 더 세분화된 마이그레이션 절차를 해야만 하는 경우가 있다.  
변경 사항을 살펴보고 함수 선언과 호출문들을 단번에 고칠 수 있을지 가늠해보고 가능할 경우에만 간단한 절차를 따른다. 그 외의 경우에는 복잡한 경우가 많기에 마이그레이션 절차를 사용하자.  

##### 간단한 절차: 
1. 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인
2. 매서드 선언을 원하는 형태로 바꾼다
3. 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정.
4. 테스트

변경할 게 둘 이상이면 나눠서 처리하는 편이 나을 때가 많다한다. 그렇기 때문에 이름 변경과 매개변수 추가를 모두 하고 싶다면 각각을 독립적으로 진행하자. 실패시 마이그레이션 절차로.  

##### 마이그레이션 절차:
1. 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링
2. 함수 본문을 새로운 함수로 추출
   1. 만일 기존 함수의 이름을 가져다 쓰고 싶다면 검색하기 쉬운 이름을 임시로 붙여둔다.
3. 추출한 함수에 매개변수를 추가해야 한다면 간단한 절차를 추가
4. 테스트
5. 기존 함수를 인라인
6. 이름을 임시로 붙여둔 상황이라면 함수 선언 바꾸기를 한 번 더 적용하여 원래 이름으로 복귀
7. 테스트

### 변수 캡슐화 하기 (Encapsulate Variable):
#### 배경:
데이터는 함수보다 다루기가 까다롭다. 데이터는 참조하는 모든 부분을 한 번에 바꿔야 코드가 정상 동작한다. 유효범위가 넓어질 수록 다루기 어려워 진다. 전역 데이터가 골치인 이유.  
그래서 접근할 수 있는 범위가 넓은 데이터의 경우 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 좋다.  

#### 절차:
1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다
2. 정적 검사를 수행
3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 바꿀 때 마다 테스트
4. 변수의 접근 범위를 제한
   1. 직접적인 접근을 막을 수 없을 때는 이름을 바꿔서 테스트 해보면 쉽게 어디서 이 변수가 쓰이는지 알 수 있다.  
5. 테스트
6. 변수값이 레코드라면 레코드 캡슐화하기 까지 적용할지 고려

### 변수 이름 바꾸기
#### 배경:
명확한 프로그래밍의 핵심 => 이름짓기.  

*이름을 잘 지은 변수*는 프로그래머가 하려는 일에 많은 것을 설명해줌.

#### 절차:
1. 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려하자
2. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경:
   1. 다른 코드베이스에서 참조하는 변수는 외부에 공개된 변수이므로 이 리팩터링을 적용할 수 없다. 
   2. 변수 값이 변하지 않는다면 다른 복제본을 만들어 점진적으로 교체 + 테스트
3. 테스트

### 매개변수 객체 만들기
#### 배경:
이 함수에서 저 함수로 몰려다니는 변수들이 있는 경우가 있다. 이런 데이터의 무리들을 발견한다면 하나의 데이터 구조로 모아주는 방식을 사용하자.  
데이터 덩어리들을 묶으면 데이터 사이의 관계가 명확해 진다는 장점이 있다. 또 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 같은 이름을 사용하기에 일관성도 높아진다. 또한 매개변수가 줄어들어 함수 파악이 쉬워진다.  

또 이런 식으로 데이터 구조를 새로 발견하여 적용하면 그 데이터 구조를 활용하는 형태로 프로그램 동작을 재구성할 수 있게 되는데, 이 과정에서 새로만든 데이터 구조가 코드의 개념적인 그림을 다시 그려 더 나은 결과물이 나오기 때문.   

#### 절차:
1. 적당한 데이터 구조가 아직 마련되어 있지 않다 -> 새로 만든다
   1. 밥 아저씨는 클래스로 만드는걸 선호. 나중에 그 객체의 동작까지 묶을 수 있기 때문에.  
2. 테스트
3. 함수 선언 바꾸기 (6,5)를 사용해 새 데이터 구조 (Object) 를 매개변수로 추가
4. 테스트
5. 함수 호출시 새로운 구조 인스턴스를 넘기도록 수정. 매 수정마다 테스트
6. 기존 매개변수를 사용하던 코드 -> 새 데이터 구조의 원소를 사용하도록 변경
7. 다 바꿨다면 기존 매개변수를 제거 -> 테스트

##### 진정한 값 객체로 거듭나기
이러한 밑작업의 가장 큰 의의는 클래스로 옮길 수 있다는 이점이 생긴다는 점이다. 이런 식으로 최대한 포장된 원시값을 유지하는 방식의 클래스를 만들 수 있는 방법이 아닐까 생각이 들었다.  

### 여러 함수를 클래스로 묶기
#### 배경:
클래스 -> 대다수 최신 프로그래밍 언어가 제공하는 기본 빌딩 블록. 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다. 객체지향 언어의 기본이며, 다른 패러다임의 언어에도 유용한 개념이다.  

공통 데이터를 중심으로 (ex: 함수 호출시 인수로 전달되는 중복적 코드들) 엮여서 동작하는 함수들을 클래스로 빼는게 밥 아저씨의 방식.  

#### 절차:
1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화
   1. 공통 데이터가 레코드 구조로 묶여 있지 않다면 먼저 매개변수 객체 만들기(6.8)로 데이터를 하나로 묶는다.
2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다. 
   1. 공통 레코드의 멤버는 함수 호출문의 인수 목록에서 제거
3. 데이터를 조작하는 로직들은 함수로 추출(6.1)해서 새 클래스로 이동

### 여러 함수를 변환 함수로 묶기
#### 배경:
정보 도출 로직이 반복되기도 하는 데, 이러한 작업들을 한데로 모아두면 검색 + 갱신을 일관된 장소에서 처리할 수 있게되고, 로직의 중복도 최소화 할 수 있다.  

이를 위해 변환 함수를 사용할 수 있는데, 변환 함수는 원본 데이터를 입력 -> 필요 정보를 모두 도출, 각각을 출력 데이터의 필드에 넣어 반환한다. 이렇게 해두면 도출 과정을 검토할 일이 생겼을 때 변환 함수만 살펴볼 수 있게된다.   

이걸 하는 대신 6.9의 여러 함수 클래스로 묶기를 사용해도 된다. 어떤 걸 쓸지는 회사의 스타일 + 이미 작성된 코드의 스타일 등을 참고하면 될 듯 하다.  
여러 함수 클래스로 묶기와 여러 함수 변환 함수로 묶기는 중요한 차이가 하나 있다. 원본 데이터가 코드 안에서 갱신되는 상황인 경우, 클래스로 묶는 편이 훨씬 좋다한다. 데이터의 일관성을 유지하기 위해.  

#### 절차:
1. 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다
   1. 대체로 깊은 복사를 통해 해결한다. 
2. 묶을 함수를 골라서 본문 코드를 변환 함수로 옮기고 처리 결과를 레코드에 새 필드로 기록. 
   1. 이 부분에서 로직이 복잡하다면 함수 추출하기 (6.1) 부터 진행한다.
3. 테스트
4. 나머지 관련 함수들에게도 1~3 진행



